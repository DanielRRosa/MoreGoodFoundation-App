// Import necessary libraries and modules
import { createSelector } from "@reduxjs/toolkit";
import { RootState } from "../../../store/store";
import { formatDayMonthYear } from "../../../utils";
import { timeEntriesAdapter, TimeEntry } from "./slice";

// Selectors generated by the Redux Toolkit adapter for the timeEntries slice
export const {
  selectById: selectTimeEntryById,
  selectIds: selectTimeEntriesIds,
  selectEntities: selectTimeEntryEntities,
  selectAll: selectAllTimeEntries,
  selectTotal: selectTimeEntriesCount,
} = timeEntriesAdapter.getSelectors((state: RootState) => state.timeEntries);

// Selector to find the current time entry with stopTime equal to 0
export const selectCurrentTimeEntry = (state: RootState) => {
  console.log(state); // Log the current state for debugging purposes
  const currentTimeEntry = Object.values(state.timeEntries.entities).find(
    (timeEntry) => timeEntry?.stopTime === 0
  );
  return currentTimeEntry;
};

// Selector to group time entries by date, sorted by stopTime, and filtered by limit if specified
export const selectTimeEntriesGroupedByDate = createSelector(
  [selectAllTimeEntries, (_, limit: number) => limit],
  (allTimeEntries, limit?: number) => {
    let timeEntries: TimeEntry[] = allTimeEntries
      .filter((entry) => entry.stopTime) // Filter out entries with stopTime falsy
      .sort((a, b) => b.stopTime! - a.stopTime!); // Sort entries by stopTime in descending order

    if (limit !== undefined) {
      timeEntries = timeEntries.slice(0, limit); // Limit the number of entries if limit is specified
    }

    // Group time entries by date
    const groupedByDate = timeEntries
      .sort((a, b) => a.startTime - b.startTime) // Sort entries by startTime
      .reduce(groupTimeEntriesByText, []) // Group entries by text content and date
      .reverse() // Reverse the order of grouped entries
      .reduce(
        groupCombinedTimeEntriesByDate,
        new Map<string, GroupedTimeEntry[]>()
      ); // Combine grouped entries into a map by date

    // Remove last (incomplete) day if there are more completed entries
    const allCompletedTimeEntries = allTimeEntries.filter(
      (entry) => entry.stopTime
    );
    if (timeEntries.length !== allCompletedTimeEntries.length) {
      const lastKey = Array.from(groupedByDate.keys()).pop();
      if (lastKey) {
        groupedByDate.delete(lastKey);
      }
    }

    return groupedByDate;
  }
);

// Define the shape of a grouped time entry
export type GroupedTimeEntry = {
  text: string;
  ids: string[];
  subEntries: TimeEntry[];
  elapsedTime: number;
  loggedTime: number;
  logged: boolean[];
  date: string;
};

// Function to group time entries by text content and date
const groupTimeEntriesByText = (
  grouped: GroupedTimeEntry[],
  current: TimeEntry
) => {
  const found = grouped.find((el) => {
    const sameName = el.text === current.text;
    const sameDay = el.date === formatDayMonthYear(current.stopTime!);
    return sameName && sameDay;
  });

  const diff = current.stopTime! - current.startTime;
  if (found) {
    // Update existing grouped entry with current time entry details
    found.elapsedTime = found.elapsedTime + diff;
    found.ids.push(current.id);
    found.subEntries.push(current);
    found.logged.push(current.logged);
    found.loggedTime =
      found.loggedTime + (current.logged ? current.loggedTime ?? 0 : 0);
  } else {
    // Create a new grouped entry for the current time entry
    grouped.push({
      text: current.text,
      ids: [current.id],
      subEntries: [current],
      elapsedTime: diff,
      date: formatDayMonthYear(current.stopTime!),
      logged: [current.logged],
      loggedTime: current.logged ? current.loggedTime ?? 0 : 0,
    });
  }

  return grouped;
};

// Type definition for a map of grouped time entries by date
type EntriesByDateMap = Map<string, GroupedTimeEntry[]>;

// Function to group combined time entries by date
const groupCombinedTimeEntriesByDate = (
  grouped: EntriesByDateMap,
  current: GroupedTimeEntry
) => {
  if (!grouped.has(current.date)) {
    grouped.set(current.date, []);
  }
  grouped.get(current.date)?.push(current);

  return grouped;
};
